---
layout:     post
title:      Python内存管理机制
subtitle:   理论的东西时间越久忘得的越多，只能多多温故，但求知新了。
date:       2020-02-12
author:     Rain
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Language
    - Python
---


Python内存管理机制主要包括以下三个方面：
* 引用计数机制
* 垃圾回收机制
* 内存池机制

# 引用计数

Python语言中，引用和对象分离！引用计数也是一种垃圾收集机制。

举个例子说明引用是什么：
```python3
a = 
b = 1
```
如上为一个简单的赋值语句，1就是对象，a就是引用，引用a指向对象1。
同理：b也是对象1的引用。通过内置函数id()返回对象的地址。

```python3
print(id(a)) #43220320
print(id(b)) #43220320
```

当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指向的对象是否相同。(**Notice：a与b内存地址相同也与小数据池有关，并不是对象值相等，就是一个对象**)


```python3
print(a is b) #True
```

在Python中，整数和短小的字符(小数据池)，Python都会缓存这些对象，以便重复使用。赋值语句，只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。

可以使用sys.getrefcount()获得引用计数，需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。

```python3
from sys import getrefcount

a = [1, 2, 3]
print(getrefcount(a)) # 2

b = a
print(getrefcount(b)) # 3
```

## 引用计数增加
1. 对象被创建：x=4
2. 另外的引用被创建：y=x
3. 被作为参数传递给函数：foo(x)
4. 作为容器对象的一个元素：a=[1, x, ‘33’]

## 引用计数减少
1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。
2.对象的引用被显式的销毁：del x ；或者del y
3.对象的引用被新的对象赋值：x=789
4.对象从一个容器对象中移除：myList.remove(x)
5.窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域


# 垃圾回收
## 引用计数
引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。

不过如果出现**循环引用**的话，引用计数机制就不再起有效的作用了
```python3
a = []
b = []
a.append(b)
b.append(a)
print a # [[[…]]]
print b # [[[…]]]
```

**循环引用**可以使一组对象的引用计数不为0，然而这些对象实际上并没有被任何外部对象所引用，它们之间只是相互引用。这意味着不会再有人使用这组对象，应该回收这组对象所占用的内存空间，然后由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放。

Python又引入了其他的垃圾收集机制来弥补引用计数的缺陷：“标记-清除“，“分代回收”两种收集技术。

## 标记清除

如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。所以先将循环引用摘掉，就会得出这两个对象的有效计数。
在实际操作中，并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命周期的维护。
这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。当成功寻找到root object集合之后，首先将现在的内存链表一分为二，一条链表中维护root object集合，成为root链表，而另外一条链表中维护剩下的对象，成为unreachable链表。之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。

## 分代回收

分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

举例：当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。


# 内存池

python内存机制层次

Python的内存机制呈现金字塔形状，-1，-2层主要有操作系统进行操作；
第0层是C中的malloc，free等内存分配和释放函数进行操作；
第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；
第3层是最上层，也就是我们对Python对象的直接操作；
Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
Python内部默认的小块内存与大块内存的分界点定在256个字节，当申请的内存小于256字节时，PyObject_Malloc会在内存池中申请内存；当申请的内存大于256字节时，PyObject_Malloc的行为将蜕化为malloc的行为。当然，通过修改Python源代码，我们可以改变这个默认值，从而改变Python的默认内存管理行为。


